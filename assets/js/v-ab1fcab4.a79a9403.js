"use strict";(self.webpackChunkblog_vue_press=self.webpackChunkblog_vue_press||[]).push([[222],{6057:(i,e,a)=>{a.r(e),a.d(e,{data:()=>t});const t={key:"v-ab1fcab4",path:"/other/display%20visibility%20opacity.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"结构",slug:"结构",children:[]},{level:2,title:"继承性",slug:"继承性",children:[]},{level:2,title:"性能",slug:"性能",children:[{level:3,title:"动画",slug:"动画",children:[]}]}],filePathRelative:"other/display visibility opacity.md",git:{updatedTime:1637925824e3,contributors:[{name:"liujunjia",email:"43411944+liujunjia1996@users.noreply.github.com",commits:1}]}}},599:(i,e,a)=>{a.r(e),a.d(e,{default:()=>n});const t=(0,a(6252).uE)('<h2 id="结构" tabindex="-1"><a class="header-anchor" href="#结构" aria-hidden="true">#</a> 结构</h2><ol><li>display: none (不占空间，不能点击)（场景，显示出原来这里不存在的结构）</li><li>visibility: hidden（占据空间，不能点击）（场景：显示不会导致页面结构发生变动，不会撑开）</li><li>opacity: 0（占据空间，可以点击）（场景：可以跟 transition 搭配）</li></ol><h2 id="继承性" tabindex="-1"><a class="header-anchor" href="#继承性" aria-hidden="true">#</a> 继承性</h2><p>opacity 和 display 会被继承：</p><p>若父元素应用了 opacity: 0 和 display: none，子孙元素无论怎么设置都是无法显示的</p><p>而若父元素应用 visibility: hidden，子孙元素应用 visibility: visible，那么该子孙元素就会毫无意外的显现出来</p><h2 id="性能" tabindex="-1"><a class="header-anchor" href="#性能" aria-hidden="true">#</a> 性能</h2><p>display: none：修改元素会造成文档回流,读屏器不会读取 display: none 元素内容，性能消耗较大</p><p>visibility: hidden：修改元素只会造成本元素的重绘，性能消耗较少，读屏器会读取 visibility: hidden 元素内容</p><p>opacity: 0：修改元素会造成重绘，性能消耗较少：</p><ul><li>在一般情况下，opacity 会触发重绘，即 <code>Recalculate style</code> =&gt; <code>Update Layer Tree</code>。不管你是否开启 GPU 提升为合成层与否</li><li>如果利用 animation 动画，对 opacity 做变化（animation 会默认触发 GPU 加速），则只会触发 GPU 层面的 composite，不会触发重绘</li></ul><h3 id="动画" tabindex="-1"><a class="header-anchor" href="#动画" aria-hidden="true">#</a> 动画</h3><p>只有 opacity 可以做动画效果，给 visibility 加 transition 只能延迟隐藏</p>',13),l={},n=(0,a(3744).Z)(l,[["render",function(i,e){return t}]])},3744:(i,e)=>{e.Z=(i,e)=>{const a=i.__vccOpts||i;for(const[i,t]of e)a[i]=t;return a}}}]);