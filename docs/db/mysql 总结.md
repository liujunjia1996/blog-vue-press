## mysql 江湖地位
![image](https://user-images.githubusercontent.com/43411944/139579867-ddfa4594-0133-4c39-bf44-8b6df20b5ee0.png)
## 为什么是b+🌲而不是二叉树 b 树 红黑树 hash
二叉树容易退化，红黑树、b 树太高，hash 范围查找不合适
## b 树和 b+ 树的区别
b+ 树只有叶子节点放数据，而 b 树所有节点都可以放数据，这样 b+ 树可以放更多的索引，树更矮，io 更少  
b+ 叶子节点同时也是一个有序链表，做全表扫描或范围查找时仅需遍历这个链表即可，比较方便
## 如果不设置主键会有什么问题？
不设置主键时，mysql 会隐式的添加一个大小为 6b 的主键；但是这个主键是多表共享的，所以可能会有并发竞争或容量不足的问题。此外，对于主从架构的 mysql 集群，binlog 为 row 格式时，不设置主键会造成从库同步时的频繁扫全表。
## 二级索引树的内节点都存储哪些信息，有没有存主键 id，如果存了，理由是什么？
二级索引树的叶子节点会存主键 id 用于回表，但是其实二级索引树的内节点也会存主键 id，这是因为内节点必须是有序排列的（用于二分查找），当二级索引的值相同时可以用 id 排序，而且就算是唯一二级索引的内节点也需要存主键 id，这又是因为二级索引可以存多个 null（null 之间也要保证有序），（内节点里面的主键 id 应该还有别的作用，事务中？redoLog中？忘了)。综上，主键的大小对数据库的整体性能水平有重要影响，所以主键数据类型的选取还是慎重些比较好。  
## UUID 为什么不能做索引
* 长度太长，int 4 b，bigint 8 b，但是 uuid 是 32 位字符串即 32 b，一个 uuid 索引占用空间是 int 的 8 倍，是 bigInt 的 4 倍，这会导致二分查找遍历的页增多，甚至可能导致 b+ 树的层高变高，并且，每个二级索引都会存储主键 id 用于回表，如果主键太长，整个表的其他索引也会被拖慢   
* 没有顺序，会将顺序写变为随机写，产生多余的页分裂，多余的页缓存失效处理   
* 比较性能不佳，字符串比大小要先查码表再比较，整形直接就比较了
## INT(11) 有什么用，有什么使用限制？  
设置 int 的显示宽度；必须在 ZEROFILL 的字段上使用，否则无效  

![image](https://user-images.githubusercontent.com/43411944/153792979-7d68fa8c-7ece-417a-a706-c17ec6d26067.png)
|              |  INT  |   INT(6)    |
|   ---------- |  -    |   ----      |
|   ZEROFILL   |  0000000001 |   000001  |
|   不设置     |  1    |   1         |
## 联表时的注意事项
1. 注意连接键的索引
2. 注意小表驱动大表
3. 左边的过滤使用 where ，右表的过滤使用 on，如果不慎用错：
   * 如在 where 条件中对右表限制，会导致数据缺失
   * 如在 on 条件中对左表限制，会导致数据多余
## 三层的树大概能存多少条数据
千万级，至于几千万要看具体情况；  
假设所有存放用户记录的叶子节点代表的数据页可以存放 100 条用户记录，所有存放目录项记录的内节点代表的数据页可以存放 1000 条目录项记录（这种假设每行大概只有 160 个字节，单行内容较少），那么：
如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。
如果B+树有2层，最多能存放 1000×100=100000 条记录。
如果B+树有3层，最多能存放 1000×1000×100=100000000 条记录，一亿。
如果B+树有4层，最多能存放 1000×1000×1000×100=100000000000 条记录。  
## 什么情况会导致走不上索引
不符合最左前缀原则  
where 条件使用了函数或进行了计算，WHERE `age`+ 10 = 30 或者 concat(`a 列`,'abc') ='111abc'  或者 `一个 String 列` = 123 (隐式类型转换) 
## 建库或建表时字符集指定为 utf8 和 utf8mb4 有什么区别
mysql 的 utf8 是 utf8mb3 的缩写，最多只能用三个字节表示一个字符，是残缺的，开发时应指定字符集为 utf8mb4。  
mysql8.0 后，默认字符集已被修正为 utf8mb4
## 聚集索引，非聚集索引
指 innodb 引擎，主键索引树的叶子节点里存储了所有字段数据的情况，不过 innodb 的二级索引 和 myisam 主键索引都是非聚集的
## 事务特点
Atomicity：原子性，要么全部成功，要么全部失败  
Consistency：一致性，事务前后从一个正确的状态转移到另一个正确的状态  
Isolation：隔离性，两个事务之间不能互相影响  
Durability：持久性，事务的修改要能一直保存  
## 隔离级别
![image](https://user-images.githubusercontent.com/43411944/139580643-d5d2abf9-a467-4bec-8b8f-9800c75ac214.png)
## 表设计三范式
每列保持原子性   
每列都与主键相关，一个表中只能保存一类数据  
每一列数据都和主键直接相关，而不是间接相关  
## 数据库引擎是库级别还是表级
表级别
## 什么是索引下推
索引下推（index condition pushdown ）简称 ICP，在 Mysql5.6 的版本上推出，用于优化查询。  
在不使用 ICP 的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给 MySQL 服务器，服务器然后判断数据是否符合条件。  
在使用 ICP 的情况下，如果存在某些被索引的列的判断条件时，MySQL 服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL 服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器。  
索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少 MySQL 服务器从存储引擎接收数据的次数。
## 什么是 MRR
MRR，全称「Multi-Range Read Optimization」。  
简单说：从普通索引中查出数据后，回表前，先根据主键进行一次排序，把「随机磁盘读」，转化为「顺序磁盘读」，从而提高了索引查询的性能。
## explain 解释，执行成本
在隔壁  
## 延迟关联优化
mysql 深翻页的时候并不是跳过 offset 行，而是取 offset + N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写：先快速定位需要的 id，然后再关联。  
这两种应该都行，第一个还可以换成 in，性能上估计也差不多。  
```sql
SELECT *
FROM t_trade_order t
	INNER JOIN (
		SELECT id
		FROM t_trade_order
		WHERE create_time BETWEEN '2019-10-17' AND '2019-10-25'
		LIMIT 1000000, 10
	) e
	ON t.id = e.id;
```
```sql
SELECT phone
FROM user
WHERE id > (
	SELECT id
	FROM user
	LIMIT 3000000, 1
)
LIMIT 0, 10;
```
## 水平分表和垂直分表
分行存，和分字段存
## 数据库分布式 id 方案
雪花号
## mysql 查询时区分大小写吗
库名表名分，字段名和字段值不分
## 什么是 redolog undolog binlog
redolog 重做日志，宕机或断电重启时使用，保证事务 acid 中的 d   
undolog 回滚日志，事务回滚和 mvcc 中使用，保证事务 acid 中的 a 和 i   
binlog 同步日志，用来主从同步，可以通过订阅 binlog 实现一些特定功能   
## mvcc
## mysql 中的锁
## mysql 相关规范
* 主键统一采用 UNSIGNED BIGINT 类型（0~18446744073709551615）
* 主键名：前缀为 pk_。以 pk_ + 主键字段名构成。如果复合主键的构成字段较多，则只包含第一个字段。表名可以去掉前缀。
* 表必需指定主键，建议采用数字类型，且为递增顺序，主键不表示任何业务含义，严禁数据量大的表使用 UUID/MD5 作为主键。
* 外键名：前缀为 fk_。以 fk + 外键表名 + 主键表名 + 外键字段名构成。表名可以去掉前缀。
* 普通索引：前缀为 idx_。以 idx_+ 索引字段名构成。
* 主键索引：前缀为 idx_pk_。以idx_pk_ + 索引字段名构成。
* 唯一索引：前缀为 idx_uk_。以idx_uk_ + 索引字段名构成。
* 外键索引：前缀为 idx_fk_。以idx_fk_ + 外键表名 + 主键表名 + 外键字段名构成。
* 没有分区的单表 2000 万内，分区表整表不超过 6000 万，库容量不超过 1.5T. 超过此数据量，需要考虑分布式中间件或历史数据迁移等手段。
* 不要在 MySQL 数据库中存放业务逻辑，禁止使用存储过程、视图、触发器、事件
* 库和表字符集统一使用 utf8mb4，校对字符集使用默认的 utf8mb4_general_ci。
* 尽可能少的使用 text、blob 类型。
* 使用逻辑外键而不是物理外键。
* 控制单表字段数量，单表字段数上限 30 左右，太多的话考虑根据冷热数据分离或者大字段和小字段分离。
* 表的设计要尽量满足第二范式（2NF），基于提升性能的考虑可以适当增加冗余而不必满足第三范式（3NF）。反范式化冗余字段考虑具体使用场景，当 SQL 关连查询比较频繁，或涉及到 4 张以上表时可考虑采用冗余字段。
* 推荐使用 timestamp 保存时间，方便支持不同时区显示和控制。
* 索引字段必须定义为 NOT NULL ？ 暂时不懂为啥
* 能确定返回结果只有一条时，使用 limit 1：在保证数据不会有误的前提下，能确定结果集数量时，多使用 limit，尽快的返回结果。？ 这个存疑，按理说，limit 是全部查出来之后再做的逻辑；如果不是，估计就是 mysql 内部做了优化，补一个 sql 的执行顺序： from join on where  group by avg,sum.... having select distinct order by limit 
* 修改表结构时 drop colum 时要注意，与这个字段相关的索引都会改变，变化是从原索引抽掉该字段定义。这种情况有可能导致部分索引重复或失效。
* 尽量不要在频繁更新的列上创建索引：如不在定义了 on update current_timestamp 的列上创建索引，维护成本太高。 ？ 这个暂时也存疑，为什么不该加就加
* 复合索引区分度大的字段放前面，利于复用。比如想用有 1000 个值的字段和一个只会有 1 或 0 的字段建立联合索引，那么 1000 个值的字段放前面，1 或 0 的字段放后面。
* 哪怕是基于索引的条件过滤，如果优化器意识到总共需要扫描的数据量超过 30% 时（ORACLE 里貌似是 20%，MySQL目前是 30%，没准以后会调整），就会直接改变执行计划为全表扫描，不再使用索引。
* 单张表的索引数量控制在 5 个以内，或不超过表字段个数的 20%。
